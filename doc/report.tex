\documentclass[a4paper, 11pt]{article}
%\usepackage{qtree} %z jakiegoś dziwacznego powodu ten pakiet musi być aż tak wysoko...
\usepackage[OT4,plmath,MeX]{polski}
\usepackage{amstext, amsopn, amsfonts, amsthm, amsbsy, latexsym, amssymb}
\usepackage[utf8]{inputenc}

\usepackage{indentfirst}
\usepackage[margin=2cm]{geometry}
\usepackage{amsmath} %found in http://en.wikibooks.org/wiki/LaTeX/Formatting
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{textcomp}

\usepackage{multirow}

\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{url}
\usepackage{hyperref}
\usepackage{multirow}
\usepackage{listings}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\begin{document}

\begin{titlepage}
\begin{center}

% Upper part of the page. The '~' is needed because \\
% only works if a paragraph has started.
\includegraphics[width=0.15\textwidth]{./include/agh-logo}~\\[1cm]

\textsc{\LARGE Akademia Górniczo-Hutnicza w Krakowie}\\
\textsc{\Large Wydział Elektrotechniki, Automatyki, Informatyki i Inżynierii Biomedycznej}\\
[1.5cm]

\textsc{\Large Projekt zaliczeniowy}\\[0.5cm]

% Title
\HRule \\[0.4cm]
{ \huge \bfseries Analizator EKG}\\[0.4cm]

\HRule \\[1.5cm]

% Author and supervisor
\begin{minipage}{0.27\textwidth}
\begin{flushleft} \large
\emph{Autorzy:}\\
 Mateusz \textsc{Baran} \\
 Krzysztof \textsc{Bębenek} \\
 Bartłomiej \textsc{Bułat} \\
 Szczepan \textsc{Czaicki} \\
 Tomasz \textsc{Drzewiecki} \\
 Krzysztof \textsc{Farganus} \\
 Łukasz \textsc{Jaromi} \\
 Mateusz \textsc{Krasucki} \\
 Łukasz \textsc{Krzyżek} \\
 Łukasz \textsc{Kutrzuba} \\
 Weronika \textsc{Łabaj} \\
 Paweł \textsc{Maślanka} \\
\end{flushleft}
\end{minipage}
\begin{minipage}{0.27\textwidth}
\begin{flushleft} \large
 \phantom{Autorzy:}
 Piotr \textsc{Matuszkiewicz} \\
 Norbert \textsc{Pabian} \\
 Łukasz \textsc{Pękala} \\
 Krzysztof \textsc{Piekutowski} \\
 Grzegorz \textsc{Pietrzyk} \\
 Łukasz \textsc{Podolski} \\
 Mikołaj \textsc{Rzepka} \\
 Agata \textsc{Sitnik} \\
 Leszek \textsc{Sosnowski} \\
 Aleksander \textsc{Steliga} \\
 Mateusz \textsc{Ślażyński} \\
 Łukasz \textsc{Zieńkowski}
\end{flushleft}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Opiekun:} \\
 mgr inż. Tomasz \textsc{Pięciak}
\end{flushright}
\end{minipage}

\vfill

% Bottom of the page
{\large \today}

\end{center}
\end{titlepage}


\setcounter{page}{2}
\tableofcontents
\newpage

\section{Specyfikacja zadania}

Celem projektu jest stworzenie zintegrowanego systemu pozwalającego na przeglądanie i automatyczną analizę sygnału EKG. Sygnał dostarczany jest w formie cyfrowej w standardzie wykorzystywanym w MIT–BIH Arrhythmia Database. Różne etapy przetwarzania, takie jak usuwanie linii bazowej, detekcja załamków R czy klasyfikacja zespołów QRS wykonywana jest przez różne zespoły (szczegółowe opisy specyfikacji modułów: \ref{sec:mod}), których praca składa się na jeden program.

Moduły przetwarzania integrowane i uzupełniane są modułami kontrolującymi przepływ danych i odpowiadającymi za komunikację z użytkownikiem. Wzajemne zależności pomiędzy modułami prezentuje rys. \ref{fig:zaleznosci}.

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.7\linewidth]{include/Projekt_zaleznosci}
  \label{fig:zaleznosci}
  \caption{Zależności pomiędzy modułami projektu.}
\end{figure}

\section{Specyfikacja techniczna rozwiązania}
\label{sec:techspec}

\subsection{Wykorzystane narzędzia}
\label{sec:tools}

Podczas realizacji projektu wykorzystywane były różne narzędzia do tworzenia i prototypowania rozwiązań. Wstępne projekty przygotowywane były w programie Matlab, zaś ostateczny kod powstawał w języku C++ (standard '03 z elementami standardu C++11 obsługiwanymi przez wspierane kompilatory).
Minimalne wymagania kompilacji projektu są następujące:
\begin{itemize}
  \item Jeden z kompilatorów:
  \begin{itemize}
    \item Microsoft Visual Studio 2010
    \item GCC 4.5
  \end{itemize}
  \item Biblioteki:
  \begin{itemize}
    \item Boost 1.51
    \item Qt 4.8
    \item Qwt 6.01
    \item gsl 1.15
    \item WFDB 10.5.16 (zawarta w źródłach projektu)
    \item FFTW 3.3.2
   \item KissFFT 1.3.0  (zawarta w źródłach projektu)
   \item ALGLIB 3.7.0   (zawarta w źródłach projektu)
  \end{itemize}
\end{itemize}

Do wersjonowania i śledzenia błędów wykorzystywaliśmy platformę Github wraz z rozproszonym systemem kontroli wersji Git. Posiada on zaawansowane możliwości wspierające pracę grupową nad projektem, co szczególnie przydaje się, gdy liczba osób jest duża.

\subsection{Projekt systemu}
\label{sec:sys_proj}

Program został wykonany w architekturze MVC -- istnieje ścisły podział na część wyświetlającą interfejs użytkownika, moduły przetwarzania sygnału oraz kontroler łączący te dwa elementy, co obrazuje diagram pakietów \ref{fig:package_diagram}. Zastosowano obiektowe podejście przy projektowaniu hierarchii klas realizujących przetwarzanie (rys. \ref{fig:class_diagram}), umożliwiające bezproblemową wymianę implementacji dowolnego modułu na inną.

\begin{figure}[h!]
  \centering
  \includegraphics[width=\linewidth]{include/package_diagram}
  \label{fig:package_diagram}
  \caption{Diagram pakietów.}
\end{figure}

Samo przetwarzanie realizowane jest wielofazowo -- moduły przeliczane są sekwencyjnie na osobnym wątku niż wątek zdarzeń GUI, co pozwala na zatrzymanie zbyt długo trwającej operacji. Zaimplementowano także mechanizm buforowania wyników, dzięki czemu przy zmianie parametrów pewnego modułu nie ma konieczności przeliczania wyników modułów wcześniejszych.

Cała aplikacja napisana jest jako samodzielny, wieloplatformowy program (rys. \ref{fig:deployment_diagram}) -- możliwa jest kompilacja pliku binarnego pod systemami Windows, Linux i MacOS X. Całe przetwarzanie wykonywane jest lokalnie, dzięki czemu nie jest wymagane połączenie z Internetem. Dzięki wybraniu licencji GPL v2+ projekt jest wolny i możliwy jest jego dalszy rozwój i kompilacja na nowe platformy.

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.5\linewidth]{include/deployment_diagram}
  \label{fig:deployment_diagram}
  \caption{Diagram wdrożenia.}
\end{figure}

Diagram sekwencji przedstawiający sposób uruchamiania modułów jest przedstawiony na rys. \ref{fig:sequence_diagram}. Każdy moduł otrzymuje najpierw zestaw parametrów (o ile posiada jakieś parametry), następnie zaś jest uruchamiany funkcją runModule. Kolejne moduły uruchamiane są sekwencyjnie według identycznego schematu. Wskutek akcji użytkownika możliwe jest przerwanie analizy pomiędzy poszczególnymi modułami.

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.5\linewidth]{include/sequence_diagram}
  \caption{Diagram sekwencji.}
  \label{fig:sequence_diagram}
\end{figure}

Diagramy klas zostały przedstawione, z~uwagi na wielkość na trzech rysunkach. Rys. \ref{fig:controller-modules} obrazuje zależności pomiędzy poszczególnymi klasami zrealizowanymi w ramach modułów, klasami abstrakcyjnymi oraz kontrolerem. Rys. \ref{fig:modules-model} przedstawia zależności pomiędzy klasami modułów a~klasami realizującymi model. Rys \ref{fig:controller-gui} przedstawia połączenie kontrolera z klasą odpowiadającą za GUI.

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.9\linewidth]{include/controller-modules}
  \caption{Diagram klas kontrolera i~modułów.}
  \label{fig:controller-modules}
\end{figure}

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.9\linewidth]{include/modules-model}
  \caption{Diagram klas modułów i modelu.}
  \label{fig:modules-model}
\end{figure}

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.9\linewidth]{include/controller-gui}
  \caption{Diagram klas kontrolera i GUI.}
  \label{fig:controller-gui}
\end{figure}

Diagram przypadków użycia, przedstawiony na rys. \ref{fig:use_case_diagram} pokazuje różne scenariusze, w których może być używany zrealizowany system. Każdemu przypadkowi odpowiada jeden lub więcej modułów. zachodzące pomiędzy nimi zależności są ukazywane relacjami zawierania.
\begin{figure}[h!]
  \centering
  \includegraphics[width=\linewidth]{include/use_case_diagram}
  \caption{Diagram klas.}
  \label{fig:use_case_diagram}
\end{figure}

\subsection{Główne elementy kodu systemu}

Głównym elementem systemu jest klasa \verb+ECGController+ \ref{fig:class_diagram}. Metoda \verb+rerunAnalysis+, która się w niej znajduje odpowiada za kilka rzeczy:
\begin{enumerate}
\item Upewnianie się, że moduły mają aktualne parametry.
\item Rozpoczynanie analizy zapisu EKG.
\item Przerywanie analizy w przypadku, gdy już ona trwa.
\item Raportowanie do GUI o kolejnych etapach pracy systemu (który moduł aktualnie się wykonuje).
\end{enumerate}
Ostatnie zadanie wykonywane jest za pomocą dwóch funkcyjnych argumentów wejściowych.

Parametry, ustawiane metodami \verb+setParam*+ mają postać mapy przypisującej nazwom poszczególnych parametrów odpowiadające im wartości liczbowe. Wykorzystywane są przede wszystkim w modułach usuwania linii bazowej oraz wykrywania załamków R.

Do klas pomocniczych można zaliczyć między innymi \verb+IntSignal+ czy \verb+ECGSignalChannel+. Sygnały, które przechodzą pomiędzy systemami czynią to właśnie poprzez obiekty tych klas. Są one zrealizowane jako sprytne wskaźniki do struktur trzymających wektory w stylu C biblioteki GSL, dzięki czemu możliwe jest pogodzenie szybkości działania z wygodną składnią i semantyką sprytnego wskaźnika.

Poszczególne moduły są tworzone w hierarchii obiektowej (rys. \ref{fig:class_diagram}). Umożliwia to podmianę w przyszłości modułu na lepszą implementację bez poprawiania reszty silnika oraz przyczynia się do zmniejszenia współzależności.

\section{Opisy modułów}
\label{sec:mod}

\subsection{Usuwanie linii bazowej}
\label{sec:baseline}
Autorzy: Weronika Łabaj i Piotr Matuszkiewicz.

\subsubsection{Opis zadania}
\label{sec:baseline:desc}

\begin{description}
\item[Temat] Metody filtracji i detekcji izolinii w sygnale EKG
\item[Opis] Występujące zakłócenia sieciowe i mięśniowe, jak również falowanie linii izoelektrycznej w sygnale EKG niejednokrotnie uniemożliwiają właściwą i poprawną analizę sygnału. Celem projektu jest opracowanie i implementacja metod związanych filtracją i detekcją linii izoelektrycznej w sygnale EKG. W szczególności należy rozważyć:
  \begin{itemize}
  \item filtr Butterwortha,
  \item średnią kroczącą,
  \item metody nieadaptacyjne: filtr Savitzky-Golay’a
  \item metody atapdacyjne np. filtr Wienera, LMS
  \end{itemize}
\item[Dane] ciąg próbek sygnału EKG z bazy Physionet.org
\item[Szukane] moduł programu filtrujący sygnał EKG z zakłóceń sieciowych/mięśniowych oraz usuwający z sygnału falowanie linii izoelektrycznej przy wykorzystaniu różnych metod; w ostatecznym module programu będzie możliwość wyboru algorytmu filtrującego i usuwającego falowanie linii izoelektrycznej
\end{description}

\subsubsection{Badania literaturowe}
\label{sec:baseline:papers}

\subsubsection{Opis procedur i metod}
\label{sec:baseline:procs}

\subsubsection{Warunki testowania}
\label{sec:baseline:tests}

\subsubsection{Wyniki}
\label{sec:baseline:results}

\subsection{Wykrywanie załamków R}
\label{sec:Rs}
Autorzy: Paweł Maślanka i Norbert Pabian

\subsubsection{Opis zadania}
\label{sec:rs:desc}
\begin{description}
\item[Temat] Detekcja załamka R
\item[Opis] Detekcja załamków R w przefiltrowanym sygnale cyfrowym EKG, mimo iż jest tematem przebadanym i dobrze znanym, to wciąż nie istnieje złoty standard postępowania. Alternatywą dla powszechnie znanego algorytmu "Pan-Tompkins", opartego o podstawowe przekształcenia matematyczne potęgowania i różniczkowania może okazać się transformata Hilberta odpowiednio przygotowanego sygnału. Celem projektu jest opracowanie i implementacja metod służących do detekcji załamków R w sygnale EKG w oparciu o algorytm "Pan-Tompkins" oraz zespolone przekształcenie Hilberta. Podejmując projekt należy zwrócić uwagę na problematykę wystąpienia szumu i analizy sygnału na końcach przedziału, gdzie rozważania teoretyczne transformaty Hilberta nieco odbiegają od praktycznych.
\item[Dane] przefiltrowany ciąg próbek z modułu ECG\_BASELINE
\item[Szukane] moduł programu wyznaczający numery próbek załamków R oraz zaznaczający na
wykresie wykryte załamki R. Numery próbek pozwolą na dalszą analizę ilościową
i jakościową sygnału EKG.
\end{description}

\subsubsection{Badania literaturowe}
\label{sec:rs:papers}

TODO BADANIA LITERATUROWE

\subsubsection{Opis procedur i metod}
\label{sec:rs:procs}

Implementacja modułu wykrywania załamków \verb|R| znajduje się w klasie \verb|RPeaksDetector| która rozszerza abstrakcyjny moduł wykrywania załamków \verb|R|. Klasa ta posiada implementację dwóch metod wykrywania załamków \verb|R|:
\begin{itemize}
	\item Pant-Pompkins
	\item Hilbert
\end{itemize}
Moduł na podstawie parametrów jakie otrzymuje z \verb|GUI| wybiera odpowiednią metodę detekcji. Oprócz metody detekcji możliwe jest również ustawienie ręczne parametrów takich jak:
\begin{itemize}
	\item dla metody Pant-Pompkins
	\begin{itemize}
		\item próg detekcji
		\item szerokość okna całkowania
	\end{itemize}
	\item dla metody Hilbert
	\begin{itemize}
		\item TODO JAKIE PARAMETRY
	\end{itemize}
\end{itemize}
Użytkownik może też skorzystać z automatycznej detekcji powyższych parametrów. Automatyczna detekcja jest włączona jako standardowe parametry.
Opis implementacji metod wykrywania załamków:
\paragraph{PanTompkins}
\begin{lstlisting}
bool panTompkinsRPeaksDetection(ECGSignalChannel *signal);
\end{lstlisting}
Funkcja otrzymuje na wejściu przefiltrowany sygnał \verb|ECGSignalChannel *signal| z modułu \verb|ECGBaseLine|. Z założenia sygnał jest pozbawiony składowej stałej, szumów pochodzących z mięśni orz znormalizowany w zakresie od -1 do 1. Detekcja pomija więc wstępną filtracje która została wykonana w poprzednim module. Zadania wykonywane wewnątrz można podzielić na następujące etapy:
\begin{itemize}
	\item różniczkowanie sygnału
	\item potęgowanie sygnału
	\item obliczanie szerokości okna całkowania 
	\item całkowanie sygnału ruchomym oknem
	\item obliczanie progu detekcji 
	\item wykrywanie zespołów QRS
	\item wykrywanie załamków R
\end{itemize}
Jeśli podczas wykrywania nie wystąpi żaden problem zostanie stworzony wektor z punktami w jakich zostały wykryte załamki \verb|R|. Natomiast jeśli z jakiegoś powodu wykrycie załamków nie powiedzie się zostanie rzucony wyjątek \verb|RPeaksDetectionExveption|.
\paragraph{Hilbert}
\begin{lstlisting}
bool hilbertRPeaksDetection(ECGSignalChannel *signal);;
\end{lstlisting}
Funkcja również na wejściu otrzymuje sygnał z modułu \verb|ECGBaseLine|. Zadania wykonywane podczas detekcji można podzielić następująco:
\begin{itemize}
	\item TODO
	\item TODO
	\item TODO
	\item TODO
	\item TODO
\end{itemize}
Jeśli podczas wykrywania nie wystąpi żaden problem zostanie stworzony wektor z punktami w jakich zostały wykryte załamki \verb|R|. Natomiast jeśli z jakiegoś powodu wykrycie załamków nie powiedzie się zostanie rzucony wyjątek \verb|RPeaksDetectionExveption|

\subsubsection{Warunki testowania}
\label{sec:rs:tests}
Początkowo moduł był testowany przy użyciu własnego przefiltrowanego sygnału testowego utworzonego w matlabie. Testowy sygnał został pozbawiony składowej stałej, zostały usunięte zakłócenia filtrami: dolnoprzepustowym oraz górnoprzepustowym. Cały sygnał został znormalizowany do zakresu od -1 do 1.\\
\indent Sygnał można wczytać przy pomocy funkcji jaka znajduje się w klasie \verb|RPeaksDetector| o nazwie \verb|getMockedSignal|. W pliku \verb|RPeaksDetector.h| znajdują się makrodefinicje które w prosty sposób pozwalają włączyć debugowanie procesu wykrywania sygnału oraz użycie testowego sygnału.\\
\indent Makrodefinicja \verb|USE_MOCKED_SIGNAL| włącza użycie testowego sygnału. Sygnał jaki dostarcza moduł \verb|ECGBaseLine| jest ignorowany. Dodatkowo makrodefinicja \verb|DEBUG| pozwala na wypisanie podstawowych informacji z przebiegu wykrywania załamków \verb|R|. Poniżej przedstawiamy przykładowy log:
\begin{verse}
Thersold size not found, use automatic calculated value\\ 
Input parameters for R peaks module:\\
Detection method: PanTompkins\\ 
Moving window size: 0\\ 
Thersold size: 0 \\
R peaks module started \\
Use mocked signal for R-peaks module. \\
Running module with custom parameters \\
Convolution [-0.125 -0.25 0.25 0.125] \\
Orginal signal size: 600000 \\
Exponentiation \^2 \\
Signal size after convolution: 599996 \\
Moving window integration\\
Calculating moving window size\\
Moving window size: 24 \\
Signal size after exponentiation: 599996 \\
Calculating detection thersold \\
After moving window integration signal size: 599972 \\
Final max value: 0.0438604 \\
Final mean value: 0.00221016\\
Current thresold value: 0.0109651 \\
Looking for points over thersold \\
Detect begin and end of QRS complex \\
Number of left points: 2093 \\
Number of right points: 2093 \\
Final R peaks detection \\
Number of detected R-peaks: 2093 \\
Done
\end{verse}

\indent Kiedy moduł \verb|ECGBaseLine| dostarczył nam prawidłowo przygotowany sygnał, rozpoczęliśmy testowanie na plikach pochodzących z bazy \verb|MIT_BIH|. Wyniki jakie otrzymaliśmy można znaleźć w kolejnym rozdziale.

\subsubsection{Wyniki}
\label{sec:rs:results}
Uzyskane wyniki wykrywania załamków \verb|R| dla sygnałów pochodzących z bazy \verb|MIT_BIH|.\\
\linebreak
\begin{tabular}{|c|c|c|c|c|c|}
\hline
sygnał & ilośc R & wykryte PanTompkins & wykryte Hilbert & skuteczność PanTompkins & skuteczność Hilbert\\ \hline
100   & 2273 & TODO & TODO  & TODO & TODO\\ \hline
101   & 1865 & TODO & TODO  & TODO & TODO\\ \hline
102   & 2187 & TODO & TODO  & TODO & TODO\\ \hline
103   & 2084 & TODO & TODO  & TODO & TODO\\ \hline
104   & 2229 & TODO & TODO  & TODO & TODO\\ \hline
105   & 2572 & TODO & TODO  & TODO & TODO\\ \hline
106   & 2027 & TODO & TODO  & TODO & TODO\\ \hline
107   & 2137 & TODO & TODO  & TODO & TODO\\ \hline
108   & 1774 & TODO & TODO  & TODO & TODO\\ \hline
109   & 2532 & TODO & TODO  & TODO & TODO\\ \hline
200   & 2601 & TODO & TODO  & TODO & TODO\\ \hline
201   & 2000 & TODO & TODO  & TODO & TODO\\ \hline
202   & 2136 & TODO & TODO  & TODO & TODO\\ \hline
203   & 2980 & TODO & TODO  & TODO & TODO\\ \hline
205   & 2656 & TODO & TODO  & TODO & TODO\\ \hline
207   & 2332 & TODO & TODO  & TODO & TODO\\ \hline
208   & 2955 & TODO & TODO  & TODO & TODO\\ \hline
\end{tabular}

\subsection{Waves}
\label{sec:waves}
Autorzy: Agata Sitnik i Łukasz Zieńkowski.

\subsubsection{Opis zadania}
\label{sec:st_interval:desc}
Celem modułu było wykrycie zespołów QRS oraz załamków P i T.
Zespół QRS to największy zespół załamków EKG. Opisuje depolaryzację (pobudzenie) mięśni komór serca i składa się z jednego lub kilku załamków określanych kolejno jako Q, R i S, w zależności od miejsca wystąpienia i kierunku wychylenia. Czas trwania zespołu prawidłowo wynosi od 0,6-0,11 s i składa się z następujących składowych:
\begin{itemize}
     \item \verb|Załamek Q| - pierwsze ujemne wychylenie zespołu QRS
     \item \verb|Załamek R| - pierwsze dodatnie wychylenie zespołu QRS
     \item \verb|Załamek S| - każde ujemne wychylenie za załamkiem R
\end{itemize}

Poza zespołem QRS możemy wyróżnić również załamki P i T.
Załamek P odpowiada depolaryzacji przedsionków. W warunkach prawidłowych jest on dodatni w odprowadzeniach I, II, aVF i ujemny w aVR; czas jego trwania jest krótszy od 0.12 s, a amplituda nie przekracza 2.5 mm w odprowadzeniach kończynowych.
Odcinek PQ odpowiada repolaryzacji przedsionków. W warunkach prawidłowych repolaryzacja przedsionków nie powoduje przemieszczenia odcinka PQ w stosunku do odcinka TP i odcinek PQ przebiega w linii izoelektrycznej.
Odstęp PQ jest elektrokardiograficznym odpowiednikiem czasu wędrowania bodźca z węzła zatokowego
przez prawy przedsionek, węzeł przedsionkowo - komorowy, pęczek Hisa i włókna Purkinjego aż do mięśnia komór. W warunkach prawidłowych czas jego trwania zależy od wieku badanej osoby i częstotliwości rytmu serca mieszcząc się w granicach od 0.12 s do 0.20 s; u osób w starszym wieku za górną granicę normy można przyjąć wartość 0.23 s.
Odcinek ST jest elektrokardiograficznym odpowiednikiem czasu wędrowania bodźca z węzła zatokowego przez prawy przedsionek, węzeł przedsionkowo - komorowy, pęczek Hisa i włókna Purkinjego aż do mięśnia komór. W warunkach prawidłowych czas jego trwania zależy od wieku badanej osoby i częstotliwości rytmu serca mieszcząc się w granicach od 0.12 s do 0.20 s; u osób w starszym wieku za górną granicę normy można przyjąć wartość 0.23 s.
Załamek T odpowiada fazie szybkiej repolaryzacji mięśnia komór. Prawidłowy załamek T jest dodatni w odprowadzeniach I, II, aVL, V3 - V6 a ujemny w aVR.


\subsubsection{Badania literaturowe}
\label{sec:st_interval:papers}
W literaturze można znaleźć kilka rozwiązań problemu odnalezienia zespołów QRS i załamków P i T. Większość z nich opiera się na dyskretnej transformacie falkowej, która polega na splocie
sygnału pochodzącego z zapisu badania EKG z wybraną falką, pobraną z bazy. Baza jest stale rozwijana o nowe falki. Filtry cyfrowe analizy falkowej odpowiadają falce i funkcji skalującej w postaci tzw.
spline’ów bramkowych drugiego stopnia o zwartym i krótkim nośniku. Dzięki temu
podczas analizy sygnału i detekcji osobliwości możemy dokładniej kontrolowa parametry
procesu separacji wybranych częstotliwości. Dzięki analizie wieloskalowej możliwe jest
zlokalizowanie miejsca gwałtownej zmiany sygnału, a tym samym lokalizacji zespołu QRS.
Metoda posiada mniejszą wrażliwość na zmiany morfologii kolejnych zespołów QRS,
minimalizuje problemy związane z występowaniem składowej wolnozmiennej, artefaktów
ruchu i napięcia mięśni oraz pozwala na łatwiejszą separację załamka R w stosunku do
załamków P i T.

Wiele rozwiązań zagadnienia detekcji zespołów QRS opiera się na filtracji adaptacyjnej,
zastosowaniu ukrytych modeli Markova, algorytmów genetycznych lub
transformacie Hilberta. Wszystkie opierają się na pomyśle utworzenia detektora zespołów QRS, jednak pozwalają jedynie na dropną poprawę
skuteczności lub szybkości działania, gdyż tak naprawdę nie znaleziono jeszcze w 100\% skutecznej funkcji detekcyjnej. 
Istnieją dane literaturowe, w których detekcja zespołów QRS opiera się na stosowaniu filtrów wysokopasmowych. Filtry pełnią rolę narzędzia różniczkującego, a wykorzystywane są pierwsze i drugie pochodne sygnału. Różniczkowanie w tych metodach wykonuje się w celu uwypuklenia cech charakterystycznych sygnału. Zróżniczkowany sygnał poddaje się progowaniu. Pozwala to na wykrycie potencjalnych zespołów QRS, a dodatkowe progi pozwalają eliminować fałszywych kandydatów. Próg składa się z trzech parametrów: adaptacyjnej wartości slew-rate, drugiej wartości, która rośnie gdy w sygnale obserwuje się wzrost częstotliwości i trzeciej mającej na celu uniknięcie braku niskich wartości amplitudy. Zaletą tych metod jest ich prostota, a wadą niska efektywność i skomplikowane ciągi decyzyjne. Istnieją również metody łączące tosowanie filtrów wysokoprzepustowych z niskoprzepustowymi, pozwala to zwiększyć efektywność wykrywania zespołów QRS.


Jedną z najbardziej innowacyjnych metod automatycznej detekcji zespołów QRS
jest stosowanie do tego celu sieci neuronowych typu wielowarstwowego
perceptronu lub sieci LVQ. Budowa sieci MLP opiera się na konstrukcji z prostych neuronów o funkcji przejścia w postaci
tangensa hiperbolicznego lub sigmoidy. Liczba warstw sieci nie powinna
przekraczać 3, a liczba neuronów również powinna być ograniczona. 
Sieć neuronowa MPL działa na zasadzie próby przewidzenia stanu
przyszłego w oparciu o stan poprzedni. Wadą tego rozwiązania jest to, że najpierw należy przeprowadzić uczenie sieci oraz duża wrażliwość na zaszumienie sygnału.  Sieci typu LVQ działają inaczej: neurony środkowej warstwy uczą się rozpoznawania
sygnałów określonego typu. Ich liczba określa liczbę grup sygnałów.
Wadą sieci LVQ jest to, że jest bardzo rozbudowana oraz
wymaga dosyć dużego zbioru testowego. Jednak dobrze nauczona sieć typu LVQ działa w zasadzie dla każdego zapisu EKG.
Obie metody MLP i LVQ wymagają jednak
dużego nakładu pracy przy tworzeniu sieci oraz ich uczeniu. Ważne jest również to, ze błędnie przeprowadzony sposób uczenia, może znacząco pogorszyć wykrywalność zespołów QRS.

W przypadku tego projektu zdecydowano się na wykorzystanie algorytmu treshold based detection.


\subsubsection{Opis procedur i metod}
\label{sec:st_interval:procs}
Detekcja opiera się na algorytmie \verb|treshold based detection|.


zastosowane funkcje:


\begin{lstlisting}
bool QRSPointsDetector::detectQRS()
\end{lstlisting}
Główna funkcja odpowiedzialna za detekcję zespołów QRS. Funkcja korzysta ze znajomości położenia
załamków R, uzyskanych z modułu Rpeaks. Określa ona minima po obu stronach tych załamków,
następnie wykonuje normalizację sygnału, na którą składa się:
\begin{itemize}
     \item odjęcie średniej z całego sygnału
     \item spotęgowanie (wzmocnienie)
     \itempodzielenie przez maksymalną wartość występującą w sygnale (otrzymujemy sygnał
w zakresie 0-1)
\end{itemize}

Po normalizacji w funkcji jest wydzielana część sygnału o intensywności powyżej 5\%, które ma na
celu wyzerowanie sygnału poza obszarem QRS. Funkcja służy do obliczenia parametrów \verb|QRS_onset| i
\verb|QRS_end|.

\begin{lstlisting}
bool QRSPointsDetector::detectPT()
\end{lstlisting}

Główna funkcja odpowiedzialna za detekcję załamków P i T. Funkcja najpierw wstępnie przetwarza
otrzymany sygnał, wraz z oznaczonymi miejscami występowania zespołów QRS. Pierwszym etapem jest
wyzerowanie sygnału w miejscach występowania QRS. Następnie wykonywana jest normalizacja sygnału
składająca się z następujących etapów:
\begin{itemize}
     \item Każdą część sygnału znajdującą się w okresie podzielić przez maksymalną wartość w danym okresie
     \item Filtracja sygnału
     \item Odjęcie mediany dla danego okresu od wszystkich wartości w okresie
     \item wydzielenie części sygnału o intensywności powyżej 7\% (usunięcie sygnału poza
QRS)
\end{itemize}

Funkcja następnie wykonuje właściwą detekcję załamków P i T. Ich wykrycie opiera się na następujących
założeniach:
\begin{itemize}
     \item Załamek T zawsze jest dłuższy niż 90 próbek (najmniejszy zanotowany to 95, a
największy 208).
     \item Długość załamka jest większa niż 30\% długości okresu.
     \item Odległość między końcem załamka T, a początkiem następnego QRS jest zawsze
większa niż 25\% długości okresu.
     \item Załamek P zawsze jest dłuższy niż 9 próbek (najmniejszy zanotowany to 10).
     \item Odległość między początkiem załamka P, a początkiem następnego QRS jest
zawsze mniejsza niż 23\% długości okresu.
\end{itemize}

W celu wyznaczenia załamków P i T w funkcji są najpierw wyznaczane początki załamków T jako
końce poprzedzającego go zespołu QRS . W danym okresie sygnału wynikowego, funkcja znajduje
pierwszą próbkę, której wartość jest różna od zera (dalej pod nazwą próbka pierwsza). Następnie
znajduje pierwszą próbkę po tej poprzedniej, której wartość jest równa zero (dalej pod nazwą próbka
druga). Jeżeli odległość pomiędzy początkiem następnego zespołu QRS, a tą pierwszą próbką
jest większa niż 25\% długości okresu i jednocześnie odległość między drugą próbką, a końcem
poprzedzającego ją QRS jest większa niż 90, oznacza to, że druga próbka jest końcem załamka T.
Pierwsze z tych założeń zapobiega zidentyfikowaniu załamka P jako T, w przypadku gdy T jest
odwrócone i w sygnale wynikowym nie występuje. Drugie z założeń mówiące o szerokości załamka
T, zapobiega zaklasyfikowaniu szumów o małej długości jako załamka T.


\begin{lstlisting}
double findMinimum (ECGSignalChannel *signal,int forBegin, int forEnd)
\end{lstlisting}
Funkcja znajdująca minimum lokalne w danym zakresie sygnału, parametry forBegin i forEnd
określają początek i koniec analizowanego okna.

\begin{lstlisting}
double findMaximum (ECGSignalChannel *signal,int forBegin, int forEnd)
\end{lstlisting}
Funkcja znajdująca maksimum lokalne w danym zakresie sygnału, parametry forBegin i forEnd
określają początek i koniec analizowanego okna.

\begin{lstlisting}
void QRSPointsDetector::runModule(const ECGSignalChannel &filteredSignal, const ECGInfo &
ecgi, const ECGRs &ecgRs, ECGWaves & ecgWaves)
\end{lstlisting}
Funkcja uruchamiająca moduł

Parametry:
\verb|&filteredSignal| - przefiltrowany sygnał

\verb|& ecgi| - informacje o sygnale

\verb|&ecgRs| - położenie załamków R

\verb|& ecgWaves| - informacja zwrotna - położenie zespołów QRS i załamków P i T

\begin{lstlisting}
ECGSignalChannel QRSPointsDetector::gradient(ECGSignalChannel * signal)
\end{lstlisting}

\begin{lstlisting}
ECGSignalChannel QRSPointsDetector::averageFilter(ECGSignalChannel * signal)
\end{lstlisting}

Funkcja realizująca filtr uśredniający sygnał

\begin{lstlisting}
ECGRs QRSPointsDetector::getMockedRPeak()
\end{lstlisting}
Funkcja ustawiająca wartości załamków R, używana do testowania modułu.

\begin{lstlisting}
ECGSignalChannel QRSPointsDetector::getMockedSignal()
\end{lstlisting}
Funkcja ustawiająca wartości sygnału, używana do testowania modułu.



\subsubsection{Warunki testowania}
\label{sec:st_interval:tests}

W celu przetestowania algorytu najpierw wykonano implementację w programie Matlab 2009, sprawdzenie akuteczności algorytmu wykonano na sygnałach ściągniętych z bazy wykorzystywanej w poprzednim semestrze na zajęciach z przedmiotu Przetwarzanie sygnałów w systemach diagnostyki medycznej. 
Następnie kod przepisano w C++ w środowisku VisualStudio 2010 i tam testowano go za pomocą tych samych sygnałów. Posłużono się jako danymi wejściowymi również wygenerowanym wektorem położenia załamków R.

\subsubsection{Wyniki}
\label{sec:st_interval:results}
\begin{center}
%
\begin{figure}
\begin{centering}
\includegraphics[scale=0.4]{include/waves_matlab}
\par\end{centering}

\caption{Wyniki modułu Waves -- Matlab, oznaczne zespoły QRS i załamki R}
\label{fig:waves_matlab}
\end{figure}

\par\end{center}


\begin{center}
%
\begin{figure}
\begin{centering}
\includegraphics[scale=0.4]{include/waves_matlab2}
\par\end{centering}

\caption{Wyniki modułu Waves -- Matlab, oznaczne załamki P, T i R }
\label{fig:waves_matlab2}
\end{figure}

\par\end{center}

\begin{center}
%
\begin{figure}
\begin{centering}
\includegraphics[scale=0.4]{include/waves_cpp}
\par\end{centering}

\caption{Wyniki modułu Waves -- Visual Studio 2010}
\label{fig:waves_cpp}
\end{figure}

\par\end{center}

Udało się osiągnąć zadowalające wyniki, które nieznacznie odbiegają od danych przewidywanych. 
Wyniki osiągnięte podczas wstępnej implementacji w Matlabie, gdzie wykonano oznaczenia początków i końców zespołów QRS \ref{fig:waves_matlab} oraz następnie oznaczono położenie załamków P i końców załamków T \ref{fig:waves_matlab2} są nieznacznie gorszej jakości niż uzyskane później w wynikowym programie \ref{fig:waves_cpp} . Jest to spowodowane między innymi tym, że program w Matlabie był przygotowany jako prototyp, który później został dopracowany i rozszerzony o dodatkowe warunki klasyfikacji sygnału jako załamki oraz o dodatkową filtrację.




\subsection{HRV1}
\label{sec:hrv1}

Autorzy: Łukasz Jaromir i Leszek Sosnowski
\subsubsection{Opis zadania}
\label{sec:hrv1:desc}
\begin{description}
\item[Temat] Analiza zmienności rytmu serca (HRV) \#1
\item[Opis] Zmienność rytmu zatokowego opisuje różnice w długościach interwałów RR
wyznaczanych przez kolejne szczyty zespołów QRS. Występowanie tych różnic świadczy
o zdolności serca do adaptacji względem zewnętrznych bodźców i przedstawia informacje
o pracy autonomicznego systemu nerwowego. Najprostsze ze stosowanych metod to analiza
statystyczna w dziedzinie czasu oraz analiza częstotliwościowa. Celem projektu jest
opracowanie i implementacja metod czasowych oraz częstotliwościowych analizy zmienności
rytmu serca.
\item[Dane] ciąg próbek załamków R z modułu RPEAKS
\item[Szukane] moduł programu wyznaczający, wyświetlający parametry analizy czasowej
i częstotliwościowej, a także rysujący postać częstotliwościową tachogramu wraz
z naniesionymi zakresami parametrów HF, LF, VLF, ULF
\end{description}

\subsubsection{Badania literaturowe}
\label{sec:hrv1:papers}
Ocena zmienności rytmu serca jest podstawową techniką umozliwiającą ocenę wpływu układu współczulnego (pobudzanie) i przywspółczulnego (hamowanie) na akcję serca. Ponieważ rola tych układów silnie zależy od stanu człowieka (sen, czuwanie) dopiero analiza całodobowych zmian rytmu serca pozwala diagnozować poprawność tego współdziałania.

Analiza zmienności rytmu serca opiera się na bieżących wartościach interwałów międzyuderzeniowych (odstępów RR) i może być prowadzona:
\begin{itemize}
\item w dziedzinie czasu (metodami statycznymi),
\item metodami geometrycznymi (aproksymacja histogramu trójkątem),
\item metodami częstotliwościowymi (z wykorzystaniem funkcji autokorelacji lub przekształcenia Fouriera).
\end{itemize}

Tachogram (po uzupełnieniu luk po zespołach QRS innych niż nadkomorowe) może być podstawą wyznaczania statycznych i geometrycznych współczynników zmienności akcji serca:
\newline
\begin{tabular}{|l|l|}
\hline
Oznaczenie: & Znaczenie wskaźnika \\ \hline
Średni RR & Wartość średnia ze wszystkich odstępów RR rytmu zatokowego \\ \hline
SDNN & odchylenie standardowe interwałów RR (ang. standard deviation normal-to-normal) \\ \hline
rMSSD & pierwiastek kwadratowy ze średniej kwadratów różnic pomiędzy kolejnymi dwoma interwałami RR \\ \hline
NN50 & liczba interwałów RR, których różnica przekracza 50 ms \\ \hline
pNN50 & odsetek różnic pomiędzy interwałami RR, które przekraczają 50 ms [\%] \\ \hline
SDANN & odchylenie standardowe ze wszystkich średnich interwałów RR w 5 minutowych segmentach czasu całego zapisu [ms] \\ \hline
SDANNindex & średnia z odchyleń standardowych interwałów RR w 5 minutowych segmentach czasu całego zapisu [ms] \\ \hline
SDSD & odchylenie standardowe różnic pomiędzy dwoma sąsiadującymi interwałami RR [ms] \\
\hline
\end{tabular}
\linebreak

Analiza zmienności rytmu serca w dziedzinie częstotliwości wymaga rozwiązania problemu dotyczącego natury sygnału: tachogram jest dyskretną funkcją czasu próbkowaną niejednorodnie (interwał próbkowania nie jest stały). Konieczne jest więc odtworzenie ciągłej funkcji czasu na podstawie posiadanego tachogramu, a następnie ponowna jej dyskretyzacja w sposób jednorodny.
Algorytm interpolacji, który wybraliśmy to algorytm interpolacji funkcjami sklejanymi trzeciego stopnia.

Kolejnym krokiem jest stosowanie przekształcenia Fouriera w celu otrzymania widma sygnału. Wykres widma dzielony jest zwykle na pasma, w których określana jest całkowita moc wyrażana następnie przy użyciu współczynników:

\begin{tabular}{|c|l|}
\hline
Oznaczenie: & Znaczenie wskaźnika \\ \hline
TP & całkowita moc widma (większe lub równe 0.4 Hz)  \\ \hline
HF & moc widma w zakresie wysokich częstotliwości (0.15 − 0.4 Hz) \\ \hline
LF & moc widma w zakresie niskich częstotliwości (0.04 − 0.15 Hz) \\ \hline
VLF & moc widma w zakresie bardzo niskich częstotliwości (0.003 − 0.04 Hz)  \\ \hline
ULF & moc widma w zakresie ultra niskich częstotliwości (0.003 Hz)  \\ \hline
LFHF & stosunek mocy widm w zakresie niskich częstotliwości do wysokich częstotliwości  \\
\hline
\end{tabular}


Analiza częstotliwościowa dostarcza informacji o dynamicznej równowadze układu autonomicznego umożliwiając ocenę współpracy układu współczulnego i przywspółczulnego. Współczynniki analizy częstotliwościowej HRV dobrze reprezentują zjawiska zmienności. (za: Piotr Augystyniak \textit{Przetwarzanie sygnałów elektrodiagnostycznych}).

\subsubsection{Opis procedur i metod}
\label{sec:baseline:procs}
Klasą realizującą obliczenia parametrów analizy czasowej i częstotliwościowej jest klasa HRV1Analyzer.
Metody w klasie HRV1Analyzer:
\begin{itemize}
\item HRV1Analyzer::HRV1Analyzer() - konstruktor klasy
\item HRV1Analyzer::~HRV1Analyzer() - destruktor klasy
\item void HRV1Analyzer::runModule(const ECGRs \& r\_peaks\_data, ECGHRV1 \& hrv1\_data) - metoda wywoływana przez kontroler służąca do uruchomienia modułu
\item void HRV1Analyzer::run() - metoda odpowiedzialna za uruchomienie algorytmów liczenia współczynników
\item void HRV1Analyzer::setParams(ParametersTypes \&parameterTypes) - metoda odpowiedzialna za ustawianie parametrów (w naszym module nie wykorzystywana)
\item double* HRV1Analyzer::cubicSpline(double* x, double* y, int nframe) - funkcja odpowiedzialna za interpolowanie próbek (wykonywana jest interpolacja funkcjami sklejanymi trzeciego stopnia)
\item kiss\_fft\_cpx* HRV1Analyzer::copycpx(double *mat, int nframe) - funkcja alokująca klasę z danymi potrzebnymi do realizacji transformaty Fouriera
\item double HRV1Analyzer::mean(double *tab, int start, int end) - funkcja obliczająca średnią arytmetyczną
\item double HRV1Analyzer::std(double *tab, int start, int end) - funkcja obliczająca odchylenie standardowe
\end{itemize}

Klasą przechowywującą współczynniki analizy częstotliwościowej i czasowej jest klasa ECGHRV1.

Szukając bilbioteki odpowiedzialnej za realizację transformaty Fouriera skupiliśmy się na znaleziu narzędzia maksymalnie prostego i szybkiego aby kod pozostał zoptymalizowany. Zdecydowaliśmy się na darmową bilbiotekę KISS (Keep it Simple, Stupid).

Tymi samymi przesłankami kierowaliśmy się szukając biblioteki odpowiedzialnej za interpolowanie sygnału. Nasz wybór padł na bibliotekę algib.

\subsubsection{Warunki testowania}
\label{sec:hrv1:tests}

Jako, że realizacja projektu odbywała się w grupach i tempo pracy było różne musieliśmy sobie poradzić i rozpocząć testowanie nie mając R\_PEAKów. Do tego celu stworzyliśmy prosty algorytm, który emulował pracę całego kontrolera. Program ten na wejście podawał zmienne, które w przyszłości otrzymalibysmy z grupy R\_PEAKs - korzystaliśmy z materiałów, które otrzymaliśmy w poprzednim semestrze realizując w Matlabie laboratorium HRV1. Program zwracał natomiast policzone współczynniki analizy czasowej i częstotliwościowej.

W ten sposób, mogliśmy skutecznie pracować nad optymalizacją algorytmów porównując otrzymane wyniki z tymi, które pochodziły z prototypu napisanego w Matlabie, czekając na sprzężenie naszego modułu z modułem R\_PEAKS.

\subsubsection{Wyniki}
\label{sec:hrv1:results}
Pierwszy etap prac, który zakończyliśmy implementując metody odpowiedzialne za obliczanie poszczególnych współczynników, pozwolił nam na ich porównanie do tych otrzymywanych z prototypu napisanego w środowisku Matlab. Były one zbliżone, ale nie satysfakcjonujące: brak algorytmu aproksymacji w sposób istotny zwiększał błędy.

Dopiero dalsze poprawki i optymalizacja, a przede wszystkim implementacja algorytmu aproksymacji skutecznie zminimalizował błędy, tak że wyniki przez nas otrzymane były zadowalające.


\subsection{HRV2}
\label{sec:hrv2}

Autor: Krzysztof Farganus


\subsubsection{Opis zadania}
\label{sec:hrv2:desc}

Celem projektu jest opracowanie i implementacja metod geometrycznych
analizy HRV.

Dane przyjmowane przez moduł: 
\begin{itemize}
\item ciąg próbek załamków R z modułu R\_PEAKS.
\end{itemize}
Dane zwracane przez moduł:
\begin{itemize}
\item wykres histogramu 
\item wskaźnik TINN 
\item Indeks Trójkątny
\item wykres Poincare wraz z parametrami SD1 i SD2
\end{itemize}

\subsubsection{Badania literaturowe}
\label{sec:hrv2:papers}

Techniki geometryczne służą do przedstawienia długookresowej zmienności
rytmu serca \cite{hrv2-pl}. Są łatwe do uzyskania, ponieważ bazują na aproksymacji
histogramu trójkątem. Szerokość przedziałów klasowych histogramu ma
tutaj kluczowe znaczenie, gdyż jej wartość wpływa na rezultaty metod
geometrycznych. Głównie stosowany jest zakres wynoszący 7.8125 ms
(1/128 s). Powodem jest częstotliwość próbkowania sygnału o najczęściej
występującej wartości 128 Hz.

Cechy metod geometrycznych: 
\begin{itemize}
\item odporność na zakłócenia ze względu na zastosowanie technik aproksymacyjnych
\item eliminacja artefaktów zlokalizowanych poza trójkątem 
\item wyniki niezależne od jakości zapisu sygnału 
\item rezultaty zależne od czasu rejestracji 
\item wymagana duża liczba odstępów RR dla poprawnej analizy (minimalny
czas zapisu \textendash{} 20 minut) 
\end{itemize}
Do najbardziej rozpowszechnionych metod należą: 
\begin{itemize}
\item Wykres histogramu przedstawiający rozkład interwałów RR
\item Indeks trójkątny (HRV triangular index ) - całkowita liczba wszystkich
odstępów RR podzielona przez liczbę odstępów RR o najczęściej spotykanym
czasie trwania. 
\item Trójkątna interpolacja odstępów RR (TINN) \textendash{} długość podstawy
trójkąta aproksymującego histogram kolejnych odstępów interwałów RR
rytmu zatokowego wyrażana w milisekundach. 
\item Wykres Poincare - graficzna reprezentacja korelacji pomiędzy kolejnymi
interwałami , gdzie każdy odstęp RR jest opisany funkcją RR+1. Do
analizy rozproszenia punktów na wykresie stosuje się dwa deskryptory:
SD1 oraz SD2, odpowiadające odchyleniom standardowym. Pierwszy charakteryzuje
rozkład punktów w poprzek linii identyczności, natomiast drugi wzdłuż
tej linii.
\end{itemize}
\textbf{Algorytm obliczania wskaźnika TINN \cite{hrv2-eng}}

Aby obliczyć parametr TINN, czyli wyznaczyć wartości punktów N i M
należy opracować funkcję multiliniową q(t) o postaci:
\begin{itemize}
\item $q(t) = 0$ dla \ensuremath{t \le N}
\item $q(t) = 0$ dla \ensuremath{t \ge M} 
\item $q(X) = Y$ w pozostałych przypadkach
\end{itemize}
a następnie znaleźć minimum z całki o wzorze:

\begin{equation}
\int_{0}^{+\infty}\left(\: D(t)\right)-q(t)\:)^{2}dt
\end{equation}

spośród wszystkich kombinacji punktów (N,M) , gdzie D(t) to wartość
histogramu. W układzie dyskretnym poprzedni wzór wygląda następująco:

\begin{equation}
\sum(\: D(t)-q(t)\:)^{2}\rightarrow \text{minimum}
\end{equation}


przy czym dla $t\:\epsilon(0,N)$ oraz $t\:\epsilon(M,\infty)$ ma
postać: 

\begin{equation}
D(t)^{2}
\end{equation}


natomiast dla $t\:\epsilon\left\langle 0,N\right\rangle$ wygląda
następująco: 
\begin{equation}
(D(t)-q(t))^{2}
\end{equation}

Algorytm obliczania parametrów SD1 i SD2

Parametry SD1 i SD2 są wyznaczane według poniższych wzorów:

\begin{align}
SD1 &= \sqrt{\frac{1}{2}\cdot SDSD^{2}} \\
SD2 &= \sqrt{2\cdot SDNN^{2}-\frac{1}{2}\cdot SDSD^{2}}
\end{align}


gdzie:
\begin{itemize}
\item SDNN to odchylenie standardowe interwałów RR: $SDNN=\sqrt{\frac{1}{N-1}\cdot\sum_{i=1}^{N}\left(\bar{RR}-RR_{i}\right)^{2}}$
\item SDSD to odchylenie standardowe różnic pomiędzy dwoma sąsiadującymi
interwałami: $SDSD=\sqrt{E\left\{ \triangle RR_{j}^{2}\right\} -E\left\{ \triangle RR_{j}\right\} ^{2}}$
\end{itemize}

\subsubsection{Opis procedur i metod }
\label{sec:hrv2:procs}

\paragraph{\texttt{GeometricAnalysis::runModule}} -- wirtualna funkcja uruchamiająca moduł HRV2.

\medskip{}


Argumenty funkcji:
\begin{itemize}
\item \verb+ECGInfo info+ -- dane o wczytanym sygnale
\item \verb+ECGRs ecgRs+ -- wektor numerów próbek zawierający załamki R
\item \verb+ECGHRV2 ecgHRV2+ -- instancja klasy przechowującej wyniki analizy zmienności
rytmu serca metodami geometrycznymi
\end{itemize}
\medskip{}


Funkcja zwraca:

Funkcja przekazuje wyniki metod geometrycznych analizy HRV do instancji
klasy \verb+ECGHRV2+.

\medskip{}


Używane funkcje:
\begin{itemize}
\item \verb+PrepareRRSignal+
\item \verb+MakeHistogramAndGeometricalParams+
\item \verb+MakePoincareAndSDParams+
\item \verb+SetHRV2Params+\medskip{}

\end{itemize}
Używane zmienne:
\begin{itemize}
\item \verb+ECGRs rpeaks+ -- atrybut klasy \verb+GeometricAnalysis+ przechowujący wektor
numerów próbek z załamkami R
\item \verb+double SamplingInterval+ -- atrybut klasy \verb+GeometricAnalysis+ przechowujący
częstotliwość wczytanego sygnału
\end{itemize}


\medskip{}

\paragraph{\texttt{GeometricAnalysis::PrepareRRSignal}} -- funkcja przekształca wektor numerów próbek z załamkami R na wektor
interwałów RR w milisekundach.

\medskip{}


Argumenty funkcji:
\begin{itemize}
\item \verb+rpeaks+ -- wektor numerów próbek z załamkami R
\end{itemize}
\medskip{}


Funkcja zwraca:

Funkcja zapisuje wektor interwałów RR w atrybucie klasy \verb+RR_intervals+.

\medskip{}


Używane funkcje:
\begin{itemize}
\item \verb+gsl_vector_int_get+ -- metoda GSL pobierająca całkowitą wartość danego
elementu z wektora
\item \verb+gsl_vector_set+ -- metoda GSL zapisująca zmiennoprzecinkową wartość
w danym elemencie wektora
\item \verb+gsl_vector_scale+ -- metoda GSL mnożąca każdy element wektoru przez
liczbę zmiennoprzecinkową
\end{itemize}
\medskip{}


Używane zmienne:
\begin{itemize}
\item \verb+unsigned int rpeaks_size+ -- długość wektora z numerami próbek załamków
R
\item \verb+double SamplingInterval+ -- częstotliwość wczytanego sygnału
\end{itemize}

\medskip{}

\paragraph{\texttt{GeometricAnalysis::MakeHistogramAndGeometricalParams}} -- funkcja tworzy wektor wartości histogramu, oblicza wysokość i pozycję
kolumny histogramu reprezentującą najczęściej powtarzający się interwał
RR, wylicza długość oraz pozycję podstawy trójkąta aproksymującego,
oszacowuje wartość indeksu trójkątnego.

\medskip{}


Argumenty funkcji:
\begin{itemize}
\item \verb+RR_intervals+ -- wektor interwałów RR w milisekundach
\end{itemize}
\medskip{}


Funkcja zwraca:
\begin{itemize}
\item histogram\_x -- pozycje kolumn histogramu
\item histogram\_y -- wysokości kolumn histogramu
\item X -- pozycja najwyższej kolumny histogramu
\item Y -- wysokość najwyższej kolumny histogramu
\item N -- początek podstawy trójkąta aproksymującego
\item M -- koniec podstawy trójkąta aproksymującego
\item HRVTriangularIndex -- indeks trójkątny
\item TINN -- wskaźnik TINN
\end{itemize}
\medskip{}


Używane funkcje:
\begin{itemize}
\item \verb+gsl_vector_max+ -- metoda GSL zwracająca największy element danego
wektora
\item \verb+gsl_vector_min+ -- metoda GSL zwracająca najmniejszy element danego
wektora
\item \verb+gsl_vector_int_max_index+ -- metoda GSL zwracająca pozycję największego
elementu danego wektora
\item \verb+gsl_vector_int_get+ -- metoda GSL pobierająca całkowitą wartość danego
elementu z wektora
\item \verb+gsl_vector_get+ -- metoda GSL pobierająca zmiennoprzecinkową wartość
danego elementu z wektora
\item \verb+gsl_vector_set+ -- metoda GSL zapisująca zmiennoprzecinkową wartość
w danym elemencie wektora
\item \verb+gsl_vector_int_set+ -- metoda GSL zapisująca całkowitą wartość w
danym elemencie wektora
\item \verb+gsl_interp_alloc+ -- metoda GSL tworząca wskaźnik do nowo utworzonego
obiektu interpolacji
\item \verb+gsl_interp_accel_alloc+ -- metoda GSL tworząca wskaźnik na obiekt
iteratora do wyszukiwania interpolacji 
\item \verb+gsl_interp_init+ -- metoda GSL wyliczająca funkcję interpolującą
\item \verb+gsl_interp_eval+ -- metoda GSL zwracająca punkt funkcji interpolującej 
\end{itemize}
\medskip{}


Używane zmienne:
\begin{itemize}
\item \verb+double RRmax+ -- najdłuższy interwał RR
\item \verb+double RRmin+ -- najkrótszy interwał RR
\item \verb+IntSignal Histogram+ -- tymczasowy wektor punktów histogramu
\item \verb+unsigned Histogram_size+ -- liczba wszystkich kolumn histogramu
\item \verb+unsigned int RR_intervals_size+ -- liczba wszystkich interwałów RR
\item \verb+double minimum+ -- zmienna przechowująca minimalną wartość całki z algorytmu
wyznaczania TINN
\item \verb+double x[3], y[3]+ -- tablica współrzędnych trójkąta aproksymującego
\end{itemize}


\paragraph{\texttt{GeometricAnalysis::MakePoincareAndSDParams}} -- funkcja wylicza punkty wykresu Poincare oraz parametry: SD1 i SD2.

\medskip{}


Argumenty funkcji:
\begin{itemize}
\item \verb+RR_intervals+ -- wektor interwałów RR w milisekundach
\end{itemize}
\medskip{}


Funkcja zwraca:
\begin{itemize}
\item poincare\_x -- współrzędne osi OX wykresu Poincare
\item poincare\_y -- współrzędne osi OY wykresu Poincare
\item parametr SD1
\item parametr SD2
\end{itemize}
\medskip{}


Używane funkcje:
\begin{itemize}
\item \verb+gsl_vector_get+ -- metoda GSL pobierająca zmiennoprzecinkową wartość
danego elementu z wektora
\item \verb+gsl_vector_int_set+ -- metoda GSL zapisująca całkowitą wartość w
danym elemencie wektora
\item \verb+gsl_stats_sd+ -- metoda GSL wyliczająca odchylenie standardowe
\item \verb+gsl_vector_int_sub+ -- metoda GSL odejmująca dwa wektory
\end{itemize}
\medskip{}


Używane zmienne:
\begin{itemize}
\item \verb+unsigned int RR_intervals_size+ -- liczba wszystkich interwałów RR
\item \verb+IntSignal diff+ -- wektor różnic pomiędzy sąsiednimi interwałami RR
\end{itemize}
%

\paragraph{\texttt{GeometricAnalysis::SetHRV2Params}} -- funkcja przekazuje wyniki analizy HRV metodami geometrycznymi do instancji
klasy ECGHRV2.

\medskip{}


Argumenty funkcji:
\begin{itemize}
\item \verb+ECGHRV2 &hrv2+
\end{itemize}
\medskip{}


Funkcja zwraca:

Funkcja zwraca wyniki analizy geometrycznej do \verb+ECGHRV2 &hrv2+.

\medskip{}


Używane funkcje:
\begin{itemize}
\item wszystkie funkcje pozwalające na zapis wyników do atrybutów klasy
ECGHRV2. \medskip{}

\end{itemize}
Używane zmienne:

Funkcja nie używa dodatkowych zmiennych.%


\paragraph{\texttt{GeometricAnalysis::MakeRRsignal}} -- funkcja tworząca testowy wektor interwałów RR w milisekundach.

\medskip{}


Argumenty funkcji:

Nie przyjmuje argumentów.

\medskip{}


Funkcja zwraca:

Funkcja zwraca testowy wektor interwałów RR jako instancję klasy ECGRs.

\medskip{}


Używane funkcje:
\begin{itemize}
\item \verb+gsl_vector_int_set+ -- metoda GSL zapisująca całkowitą wartość w
danym elemencie wektora
\item \verb+setRs+ -- zapisuje wektor w instancji klasy ECGRs
\end{itemize}
\medskip{}


Używane zmienne:
\begin{itemize}
\item \verb+int RRsignal_length+ -- długość wektora interwałów RR
\item \verb+int RRsignal[]+ -- tablica wartości interwałów RR
\end{itemize}
%

\paragraph{\texttt{GeometricAnalysis::setParams}} -- funkcja modyfikująca szerokość kolumny histogramu.

\medskip{}


Argumenty funkcji:
\begin{itemize}
\item \verb+ParametersTypes &parameterTypes+ -- zawiera dane ustawień poszczególnych
modułów
\end{itemize}
\medskip{}


Funkcja zwraca:

Nie zwraca niczego. 

\medskip{}


Używane funkcje:
\begin{itemize}
\item \verb+parameterTypes.find(histogram_bin_length)+
- wyszukuje parametr modyfikujący szerokość kolumny histogramu\medskip{}

\end{itemize}
Używane zmienne:
\begin{itemize}
\item \verb+double HistogramParameter+ -- zmienna przechowująca rezultat funkcji \verb+parameterTypes.find+.
\item \verb+double HistogramBinLength+ -- atrybut klasy \verb+GeometricAnalysis+ przechowujący
szerokość kolumny histogramu.
\end{itemize}


\subsubsection{Warunki Testowania}
\label{sec:hrv2:tests}

Podczas procesu implementacji, moduł HRV2 poddawany był dwóm rodzajom
testów:
\begin{itemize}
\item Pierwszy test polegał na porównaniu wyników działania modułu zaimplementowanego
w Matlabie oraz Visual Studio Ultimate 2010. W tym celu jako dane
wejściowe wykorzystano wektor interwałów RR wczytywany z pliku tekstowego
dla Matlaba z tablicy jednowymiarowej dla Visual Studio.
\item Drugi test sprawdzał działanie programu, gdy ten korzystał z testowych
wyników modułu R\_PEAKS.
\end{itemize}

\subsubsection{Wyniki}
\label{sec:hrv2:results}

Rysunki \ref{fig:hrv2_1}, \ref{fig:hrv2_2} oraz \ref{fig:hrv2_3} prezentują wyniki pierwszego testu opisanego w poprzedniej
podsekcji:

\begin{center}
%
\begin{figure}
\begin{centering}
\includegraphics[scale=0.4]{include/hrv2_1}
\par\end{centering}

\caption{Wyniki modułu HRV2 -- Visual Studio Ultimate 2010}
\label{fig:hrv2_1}
\end{figure}

\par\end{center}

\begin{center}
%
\begin{figure}
\begin{centering}
\includegraphics[scale=0.7]{include/hrv2_2}
\par\end{centering}

\caption{Wykres histogramu -- Matlab}
\label{fig:hrv2_2}
\end{figure}

\par\end{center}

\begin{center}
%
\begin{figure}
\begin{centering}
\includegraphics[scale=0.7]{include/hrv2_3}
\par\end{centering}

\caption{Wykres Poincare -- Matlab}
\label{fig:hrv2_3}
\end{figure}

\par\end{center}

\subsection{HRV DFA}
\label{sec:hrvd_fa}

\subsection{Klasyfikacja zespołów QRS}
\label{sec:qrs_class}
Autorzy: Krzysztof Bębenek

\subsubsection{Opis zadania}
\label{sec:qrs_class:desc}

\begin{description}
\item[Temat] Metody detekcji morfologicznego pochodzenia zespołu QRS.
\item[Opis] Proces automatycznego klasyfikowania zespołów QRS należy do jednego z trudniejszych procesów podczas przetwarzania sygnałów EKG. Jest jednak on niezbędny w dalszych etapach analizy podczas których brane są pod uwagę tylko niepoprawne pobudzenia. Do prostych sposób oceny morfologi pobudzenia służą:
  \begin{itemize}
  \item współczynnik kształtu Malinowskiej,
  \item stosunek części ujemnej do dodatniej sygnału,
  \end{itemize}
\item[Dane] ciąg próbek przefiltrowanego sygnału EKG, wektory QRS\_onset oraz QRS\_end określające początek oraz koniec zespołu QRS
\item[Szukane] moduł programu klasyfikujący zespołu QRS na podstawie ich morfologii 
\end{description}

\subsubsection{Badania literaturowe}
\label{sec:qrs_class:papers}

\subsubsection{Opis procedur i metod}
\label{sec:qrs_class:procs}

\subsubsection{Warunki testowania}
\label{sec:qrs_class:tests}

\subsubsection{Wyniki}
\label{sec:qrs_class:results}



\subsection{ST interval}
\label{sec:st_interval}
Autorzy: Bartłomiej Bułat i Krzysztof Piekutowski.

\subsubsection{Opis zadania}
\label{sec:st_interval:desc}
Celem projektu jest wyznaczenie odcinków ST, pomiar poziomu odcinka ST względem
linii izoelektrycznej i jego nachylenia, a także detekcja epizodów ST oraz
parametry ilościowe i jakościowe epizodów ST. Celowość analizy odcinka ST
względem linii izoelektrycznej związana jest z predykcją choroby wieńcowej,
miażdżycy oraz niedotlenieniem mięśnia serca.

Dane przyjmowane przez moduł:
\begin{itemize}
  \item sygnał ECG\_BASELINE;
  \item wektor numerów próbek załamków R z modułu R PEAKS;
  \item wektor numerów próbek punktów charakterystycznych z modułu WAVES:
  \begin{itemize}
    \item $QRS_{onset}$
    \item $QRS_{end}$
    \item $T_{end}$
  \end{itemize}  
\end{itemize}

Dane zwracane przez moduł:
\begin{itemize}
  \item wektor wykrytych odcinków ST zawierających informaje:
  \begin{itemize}
    \item początek i koniec odcinka;
    \item poziom izolinii;
    \item pomiar poziomu względem izolinii;
    \item pomiar nachylenia odcinka ST;
    \item opis słowny interwału;
  \end{itemize}
  \item wektor wykrytych epizodów wraz z parametrami:
  \begin{itemize}
    \item numer próbki początku epizodu;
    \item numer próbki końca epizodu.
  \end{itemize}
\end{itemize}

\subsubsection{Badania literaturowe}
\label{sec:st_interval:papers}

\subsubsection{Opis procedur i metod}
\label{sec:st_interval:procs}

Główna funkcjonalność modułu znajduje się w klasie \verb|STAnalysis|. Klasa ta,
według przyjętego schematu rozszerza abstrakcyjny moduł analizy odcinka ST. W
tej klasie znajdują się drzewo klas prywatnych reprezentujących poszczególne
algorytmy analizy. W szczególności dwie klasy \verb|SimpleAnalizer| oraz
\verb|ComplexAnalizer|. Pierwsza klasa reprezentuje najprostszy algorytm
zaprezentowany w \cite[p.~155]{AUGUST1}, druga zaś implementuje zmodyfikowany
algorytm opisany w \cite{SHEN1}.

%% TODO: mienić nazwę funkcji w programie
Lista i opis najważniejszych funkcji:

\begin{lstlisting}
void STAnalysis::SimpleAnalizer::analyse(const int it, const ECGRs& rpeaks,
  const ECGWaves& waves, const ECGSignalChannel& signal,
  const  ECGInfo& info, ECGST& output);
\end{lstlisting}

Funkcja analizująca załamek ST w zespole QRS numer \verb|it|. Wykorzystując
punkty sygnału obliczone we wcześniejszych modułach (tj. $QRS_{onset}$,
$QRS_{end}$ oraz $T_{end}$) oblicza koniec odcinka ST i wylicza jego parametry:
\begin{itemize}
  \item przesunięcie względem izolinii
  \item wartość nachylenia w stosunku do izolini
  \item długość odcinka ST
\end{itemize}
Używając wcześniej ustawionego parametru \verb|simple_thresh|, odcinek ST
określany jest jako ,,normalny'', ,,uniesiony'' lub ,,obniżony''.

Parametry:
\begin{itemize}
  \item \verb|const int it| -- numer badanego zespołu QRS, jako liczba
    porządkowa numerów próbek z tablicy załamków R.
  \item \verb|const ECGR& rpeaks| -- struktura zawierająca tablicę numerów
    próbek kolejnych załamków R
  \item \verb|const ECGEaves& waves| -- struktura zawierająca tablice
    przechowujące numery próbek punktów charakterystycznych kolejnych zespołów
    QRS: $P_{onset}$, $QRS_{onset}$, $QRS_{end}$ oraz $T_{end}$.
  \item \verb|const ECGSignalChanel& signal| -- jeden kanał odfiltrowanego
    sygnału z usuniętym przesunięciem izolinii.
  \item \verb|const ECGInfo& info| -- struktura zawierająca informacje o badanym
    sygnale EKG, m.in. częstotliwość.
  \item \verb|ECGST& output| -- parametr wyjściowy, struktura zawierająca
    tablice wszystkich interwałów ST wraz z ich parametrami, oraz tablice
    zarejestrowanych epizodów ST wraz z ich parametrami.
\end{itemize}

\begin{lstlisting}
void STAnalysis::ComplexAnalizer::analyse(const int it, const ECGRs& rpeaks,
  const ECGWaves& waves, const ECGSignalChannel& signal,
  const  ECGInfo& info, ECGST& output);
\end{lstlisting}

Funkcja analizująca załamek ST w zespole QRS numer \verb|it|. Wykorzystując
punkty sygnału obliczone we wcześniejszych modułach (tj. $QRS_{onset}$,
$QRS_{end}$ oraz $T_{end}$) oblicza koniec odcinka ST (wykorzystując bardziej
zaawansowane algorytmy od poprzedniej funkcji), a następnie oblicza jego parametry:
\begin{itemize}
  \item przesunięcie względem izolinii,
  \item wartość nachylenia w stosunku do izolinii,
  \item długość odcinka ST,
  \item klasyfikacja kształtu.
\end{itemize}
Używając wcześniej ustawionego parametru \verb|complex_thresh|, odcinek ST
określany jest jako ,,normalny'', ,,uniesiony'' lub ,,obniżony''. Algorytm
ocenia również to, czy załamek jest prosty czy zakrzywiony w oparciu o
wcześniej ustawiony parametr \verb|type_thresh|. Dla prostych odcinków określa,
czy kierunek narasta, opada czy jest poziomy. Do określenia tej cechy
wykorzystywany jest parametr \verb|slope_thresh|. Dla zakrzywionych odcinków ST
oceniana jest wypukłość krzywej. Szczegółowy opis działania znajduje się w
poprzednim rozdziale.

Parametry:
\begin{itemize}
  \item \verb|const int it| -- numer badanego zespołu QRS, jako liczba
    porządkowa numerów próbek z tablicy załamków R.
  \item \verb|const ECGR& rpeaks| -- struktura zawierająca tablicę numerów
    próbek kolejnych załamków R
  \item \verb|const ECGEaves& waves| -- struktura zawierające tablice
    przechowujące numery próbek punktów charakterystycznych kolejnych zespołów
    QRS: $P_{onset}$, $QRS_{onset}$, $QRS_{end}$ oraz $T_{end}$.
  \item \verb|const ECGSignalChanel& signal| -- jeden kanał odfiltrowanego
    sygnału z usuniętym przesunięciem izolinii.
  \item \verb|const ECGInfo& info| -- struktura zawierająca informacje o badanym
    sygnale EKG, m.in. częstotliwość.
  \item \verb|ECGST& output| -- parametr wyjściowy, struktura zawierająca
    tablice wszystkich interwałów ST wraz z ich parametrami, oraz tablice
    zarejestrowanych epizodów ST wraz z ich parametrami.
\end{itemize}

Funkcje pomocnicze klasy \verb|ComplexAnalizer|:

\begin{lstlisting}
int STAnalysis::ComplexAnalizer::getTPeak(const OtherSignal& sig,
  int from, int to);
\end{lstlisting}

Funkcja wyszukująca położenia punktu $T_{peak}$ na zadanym odcinku sygnału.
Początkiem wyszukiwania szczytu fali T jest zwykle punkt 20ms za punktem
$QRS_{end}$, a punktem końcowym jest koniec fali T. Funkcja wykorzystuje
dyskretną pochodną sygnału.

Parametry:
\begin{itemize}
  \item \verb|const OtherSignal& sig| - cały, odfiltrowany sygnał EKG
  \item \verb|int from| - numer próbki, w której należy zacząć poszukiwania
  \item \verb|int to| - numer próbki, w której należy skończyć poszukiwania
\end{itemize}


\begin{lstlisting}
std::pair<int, double> maxDistanceSample(const OtherSignal& signal, 
  int from, int to);
\end{lstlisting}

Funkcja szukająca numeru próbki najbardziej oddalonego od liniowej interpolacji
fragmentu sygnału miedzy dwoma punktami. Oprócz numeru próbki od początku
sygnału, zwracana jest wartość największej różnicy miedzy punktem sygnału, a
prostą interpolacji.

Parametry:
\begin{itemize}
  \item \verb|const OtherSignal& signal| - badany sygnał
  \item \verb|int from| - numer próbki będącej początkiem interesującego
    fragmentu sygnału, równocześnie, pierwszy punkt interpolacji liniowej.
  \item \verb|int to| - numer próbki będącej końcem interesującego fragmentu
    sygnału, równocześnie, drugi punkt interpolacji
\end{itemize}

\begin{lstlisting}
std::pair<int, int> overBelowSamples(const OtherSignal& signal,
  int from, int to);
\end{lstlisting}

Funkcja obliczająca ilość próbek ponad i poniżej prostej interpolującej sygnał
miedzy dwoma punktami. Funkcja wykorzystywana jest do określenia wypukłości
odcinka ST.

Parametry:
\begin{itemize}
  \item \verb|const OtherSignal& signal| - badany sygnał
  \item \verb|int from| - numer próbki będącej początkiem interesującego
    fragmentu sygnału, równocześnie, pierwszy punkt interpolacji liniowej.
  \item \verb|int to| - numer próbki będącej końcem interesującego fragmentu
    sygnału, równocześnie, drugi punkt interpolacji
\end{itemize}

\subsubsection{Warunki testowania}
\label{sec:st_interval:tests}

\subsubsection{Wyniki}
\label{sec:st_interval:results}

\subsection{T wave alt}
\label{sec:t_wave_alt}

\subsection{HRT}
\label{sec:hrt}

\bibliographystyle{plain}
\bibliography{report}
\end{document}
